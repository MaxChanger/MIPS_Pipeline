00000000    =
34090001    = 0011 0100 0000 1001 0000 0000 0000 0001 
341107d0    = 0011 0100 0001 0001 0000 0111 1101 0000
341207d4    = 0011 0100 0001 0010 0000 0111 1101 0100
02298820    = 0000 0010 0010 1001 1000 1000 0010 0000
ac090000    = 1010 1100 0000 1001 0000 0000 0000 0000
ac110004    = 1010 1100 0001 0001 0000 0000 0000 0100
ac120008    = 1010 1100 0001 0010 0000 0000 0000 1000
12320001    = 0001 0010 0011 0010 0000 0000 0000 0001
08000004    = 0000 1000 0000 0000 0000 0000 0000 0100
00000000    =
00000000    =


001101 - - OriExec
000000 - - RExec    - 10 0000
101011 - - AdrCal
000100 - - BrComplete
000010 - - Jump


3c040100    =   0011 11  00000  00100  0000 0001 0000 0000


34090001    =   0011 01  00000  01001  0000 0000 0000 0001 
                OriExec  Rs     Rt     immediate(16)
                GPR[rt] GPR[rs] OR immediate
                $Rt = $Rs | Immediate
                所以最后结果中 寄存器 9 中的数据应该为1

341107d0    =   0011 01  00000  10001  0000 0111 1101 0000
                OriExec  Rs     Rt     immediate(16)
                $Rt = $Rs | Immediate
                所以最后结果中 寄存器 17 中的数据应该为2000

341207d4    =   0011 01  00000  10010  0000 0111 1101 0100
                OriExec  Rs     Rt     immediate(16)
                $Rt = $Rs | Immediate
                所以最后结果中 寄存器 18 中的数据应该为2004

02298820    =   0000 00  10001 01001 10001  000 00  10 0000
                RExec    Rs    Rt    Rd             Add
                GPR[rd] <- GPR[rs]+GPR[rt]
                所以最后结果中 寄存器 17 中数据 = 寄存器 9 中数据 + 寄存器 17 中数据 = 2001

ac090000    =   1010 11  00000  01001  0000 0000 0000 0000   lw or sw
AdrCal          sw       base   Rt     offset
                sw $v1, 8($s0)  把$Rt存储到 以Base为起始地址 偏移量为offset的位置

                memory[GPR[base]+offset] <- GPR[rt]
                所以最后结果中 寄存器 9 中的数据应该为 ？

ac110004    =   1010 11  00000  10001  0000 0000 0000 0100
AdrCal          sw       base   Rt     offset
                memory[GPR[base]+offset] <- GPR[rt]
                sw $v1, 8($s0)  把$Rt存储到 以Base为起始地址 偏移量为offset的位置

                所以最后结果中 寄存器 17 中的数据应该为 ？

ac120008    =   1010 11  00000  10010  0000 0000 0000 1000
AdrCal          sw       base   Rt     offset
                memory[GPR[base]+offset] <- GPR[rt]
                sw $v1, 8($s0)  把$Rt存储到 以Base为起始地址 偏移量为offset的位置
                所以最后结果中 寄存器 18 中的数据应该为 ？

12320001    =   0001 00  10001  10010  0000 0000 0000 0001
BrComplete      BEQ      Rs     Rt     offset
相等时跳转        if (GPR[rs] == GPR[rt])
					PC <- PC + 4 + sign_extend(offset 0 2 )
				else
					PC <- PC + 4
                如果寄存器 17 和 18 的值相等 跳转到第一个   -> 到了0x1

08000004    =   0000 10  00000  00000  0000 0000 0000 0100
                jump     instr_index
                跳转到了 -> 0x02298820


1128001c    =   0001 00  01001  01000  0000 0000 0001 1100
BrComplete      BEQ      Rs     Rt     offset
相等时跳转        if (GPR[rs] == GPR[rt])
					PC <- PC + 4 + sign_extend(offset 0 2 )
				else
					PC <- PC + 4
                如果寄存器 1
//  main:
//  	nop
//  	ori		$t1, $zero, 1
//  	ori 	$s1, $zero, 2000
//  	ori 	$s2, $zero, 2004
//  L1:
//  	add	$s1, $s1, $t1
//  	sw 	$t1, 0($zero)
//  	sw	$s2, 4($zero)
//  	sw	$s2, 12($zero)
//  	beq	$s1, $s2, L2
//  	j	L1
//  L2:
//  	nop
//  	nop
// 0x00000000 00000000 
// 0x00000001 34090001 ori	$t1, $zero, 1
// 0x00000002 341107d0 ori 	$s1, $zero, 2000
// 0x00000003 341207d4 ori 	$s2, $zero, 2004
// 0x00000004 02298820 add	$s1, $s1, $t1
// 0x00000000 ac090000 sw 	$t1, 0($zero)
// 0x00000000 ac110004 sw	$s1, 4($zero)
// 0x00000000 ac120008 sw	$s2, 8($zero)
// 0x00000000 12320001 beq	$s1, $s2, 1
// 0x00000000 08000001 j	1    // 0000 0100 0000 0000 0000 0000 0000 0001
// 0x00000000 00000000
// 0x00000000 00000000